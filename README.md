# リバーシAI

## ビルドと実行
```shell
make all
```
で`reversi`という名前の実行ファイルを生成できる．クライアントを起動するには`./reversi [OPTIONS] -n <PLAYER>`と打てばよい（`./`を付けてください）コマンドの詳細は以下の通り：
```
Usage:
Usage: reversi [OPTIONS] -n <PLAYER>

Options:
  -H <HOSTNAME>      Hostname [default: localhost]
  -p <PORT>          Port [default: 3000]
  -n <PLAYER>        Player Name
  -h, --help         Print help
```

## 方針
序盤は定石を利用し、次の打つべき手を機械的に探す。
前半ではアルファベータ法による探索を用いて良さそうな手を探す．
評価関数は，石の位置による得点と着手の可能数を考慮に入れている．
46手以降になると読み切りモードに切り替わり，最後まで探索するようになる．
ランダムな選手に対しては，100/100で勝利できている．

## 工夫
### ビットボード
盤面を二個の64ビット数で表すことで，着手可能な位置と着手後の盤面の生成を高速にできるようにした．
特に，合法手がどの方向で合法なのかについての情報は，着手可能な位置を求める際に生成されるので，これを保持することで後ほどの反転を実際に求めるステージに活かしており，無駄な計算を減らしている．

### 定石
序盤ではどのような手を打つのが一番いいのかは大体研究しつくされたので、時間節約のため既存の定石をそのまま使ったほうがいいということで、定石データベースを導入しました。
ただし、今回集められたデータがそんなに多くはないので、計算速度の向上にどれだけ寄与したのかは不明。20手前後までの定石も存在するらしいので、それを大量に集められればもっと強くなるでしょう

### 探索
基本的には自身と相手に対する最良の手を交互に求めるというアルファベータ法を使っている．
しかしアルファベータ法では，合法手の探索順が枝刈りの効率にかなり影響を与えているので，偏りを減らすためFisher–Yatesアルゴリズムであらかじめシャッフルを行っている．

### 評価関数
評価関数の設計が前半の探索にかなりの影響を及ぼす．
石の位置・可能の着手数・確定している石の数が指針となるが，[この論文](https://www.info.kindai.ac.jp/~takasi-i/thesis/2012_09-1-037-0133_S_Shiota_thesis.pdf)の内容を参考に実際にいくつかを作ってパラメータも改変しながら対戦させて比較してみた．
結果的には，石の位置（角とその隣のみ）と可能な着手数を2:1の重みで評価する設計を採用した．

### 末尾再帰
末尾再帰の形で書いていたが，プロトコルの状態遷移を管理する`game`関数と通信を行う`read_cmd_inner`でオーバーフローが起きていた．
Rustでコンパイル時にどのように末尾再帰が採用されるかを調査し，`tailcall`というライブラリを使用ことにした．

### 並列化
最初に探索する着手を複数に分けて別々のスレッド行えば，数倍の性能向上を得られるのではと思って実装をしてみた．
しかし，アルファベータ法ではその枝刈りが以前の探索に依存するため，ナイーブに並列にしてもあまり恩恵がないどころか，探索時間が伸びる場合もある．
したがって探索の深さ別の変数を作って，それらを賢くスレッド間で共有する必要がある．
こちらでは一番最初のアルファだけを共有変数にし，これよりよくなることがなかったら，その探索を取りやめるという実装を行った．
具体的な実装は`git checkout multithread`で見られる．共有変数なのでアトミックに更新するために非同期安全な参照カウント`Arc`を使った．
しかし結果的には思ったほどの性能向上が見られなかったので，提出物には含めないことにした（シングルスレッドのものと対戦させてみて互角だったので問題ないと思うが，知らないバグがあると怖い）．

## 謝辞：
本プロジェクトの一部はISerの過去の実装を参考にしました。ここで申告し、感謝申し上げます。ありがとうございました。
* Parser: Kaito Sugimotoさん　https://github.com/kaisugi/reversi
* コマンドインターフェス、評価関数: 23erのLuhao Liu
* 自分がRust未熟のため、一部の実装はどうしてもデバッグが難しい、もしくはバグが非本質過ぎて時間の無駄なので、LLMを随所使いました。
