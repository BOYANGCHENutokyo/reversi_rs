# リバーシAI

## ビルドと実行
```shell
make all
```
で`reversi`という名前の実行ファイルを生成できる．クライアントを起動するには`./reversi [OPTIONS] -n <PLAYER>`と打てばよい（`./`を付けてください）コマンドの詳細は以下の通り：
```
Usage:
Usage: reversi [OPTIONS] -n <PLAYER>

Options:
  -H <HOSTNAME>      Hostname [default: localhost]
  -p <PORT>          Port [default: 3000]
  -n <PLAYER>        Player Name
  -h, --help         Print help
```

## 方針
序盤は定石を利用し、次の打つべき手を機械的に探す。
前半ではアルファベータ法による探索を用いて良さそうな手を探す．
64マスそれぞれの静的な価値のテーブルを作って、このテーブルに従って評価する．
46手以降になると読み切りモードに切り替わり，最後まで探索する．

## 工夫
### ビットボード
盤面を二個の64ビット数で表すことで，着手可能な位置と着手後の盤面の生成を高速にできるようにした．
特に，合法手がどの方向で合法なのかについての情報は，着手可能な位置を求める際に生成されるので，これを保持することで後ほどの反転を実際に求めるステージに活かしており，無駄な計算を減らしている．

### 定石

序盤ではどのような手を打つのが一番いいのかは大体研究しつくされたので、時間節約のため既存の定石をそのまま使ったほうがいいということで、定石データベースを導入しました。
ただし、今回集められたデータがそんなに多くはないので、計算速度の向上にどれだけ寄与したのかは不明。20手前後までの定石も存在するらしいので、それを大量に集められればもっと強くなるでしょう（AIの醍醐味？）

### 探索
基本的には自身と相手に対する最良の手を交互に求めるというアルファベータ法を使っている．
しかしアルファベータ法では，合法手の探索順が枝刈りの効率にかなり影響を与えているので，偏りを減らすためFisher–Yatesアルゴリズムであらかじめシャッフルを行っている．

### 評価関数
オセロでは、隅のマスは非常に価値が高く、逆に隅のすぐ隣のマスは相手に隅を取られる危険があるため価値が低い、というセオリーがあるらしい。そのため、盤上の64マスそれぞれに静的な価値のテーブルを作って、このテーブルに従って、自分の石があるマスの価値を足し、相手の石があるマスの価値を引くことで、盤面全体の形勢を評価します。
この戦略は非常に強力で、配布されたランダムプログラムと対戦するとほとんどの場合5倍以上の大差で勝利する（直近4回: 55 vs 9, 51 vs 13, 56 vs 8, 45 vs 19）。しかし実行速度が遅い(2分以上かかる)ので、結局採用されなかった（`bitboard.rs`の。`evaluate`関数の中で`evaluator::evaluate_board(self, black_mvs, white_mvs)`を呼ぶと実行できる）
現在のプログラムは石の位置（角とその隣のみ）と可能な着手数を2:1という比率で重み付け、評価する設計を採用している．

### 末尾再帰
末尾再帰の形で書いていたが，プロトコルの状態遷移を管理する`game`関数と通信を行う`read_cmd_inner`でオーバーフローが起きていた．
Rustでコンパイル時にどのように末尾再帰が採用されるかを調査し，`tailcall`というライブラリを使用ことにした．

### 並列化
最初に探索する着手を複数に分けて別々のスレッド行えば，数倍の性能向上を得られるのではと思って実装をしてみた．
しかし，アルファベータ法ではその枝刈りが以前の探索に依存するため，ナイーブに並列にしてもあまり恩恵がないどころか，探索時間が伸びる場合もある．
したがって探索の深さ別の変数を作って，それらを賢くスレッド間で共有する必要がある．
こちらでは一番最初のアルファだけを共有変数にし，これよりよくなることがなかったら，その探索を取りやめるという実装を行った．

## 謝辞：
本プロジェクトの一部はISerの過去の実装を参考にしました。ここで申告し、感謝申し上げます。ありがとうございました。
* Parser: Kaito Sugimotoさん　https://github.com/kaisugi/reversi
* コマンドインターフェス、並列化: 23erのLuhao Liu
* 自分がRust未熟のため、一部の実装はどうしてもデバッグが難しい、もしくはバグが非本質過ぎて時間の無駄なので、LLMを随所使いました。
